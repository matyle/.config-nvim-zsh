"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuggestionsForInsideRoundBrackets = exports.getTypesFromCurrentBlock = exports.getSuggestionForSupportedFields = exports.getValuesInsideSquareBrackets = exports.suggestEqualSymbol = exports.getSuggestionForBlockTypes = exports.getSuggestionForFirstInsideBlock = exports.getSuggestionsForTypes = exports.getAllRelationNames = exports.getSuggestionForFieldAttribute = exports.getSuggestionForNativeTypes = exports.positionIsAfterFieldAndType = exports.getSymbolBeforePosition = exports.isInsideQuotationMark = exports.isInsideAttribute = exports.isInsideFieldArgument = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const completionUtil_1 = require("./completionUtil");
const klona_1 = require("klona");
const renameUtil_1 = require("../rename/renameUtil");
const previewFeatures_1 = __importDefault(require("../prisma-fmt/previewFeatures"));
// import referentialActions from '../prisma-fmt/referentialActions'
const nativeTypes_1 = __importDefault(require("../prisma-fmt/nativeTypes"));
const util_1 = require("../util");
function toCompletionItems(allowedTypes, kind) {
    return allowedTypes.map((label) => ({ label, kind }));
}
function isInsideFieldArgument(currentLineUntrimmed, position) {
    const symbols = '()';
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return (numberOfOpenBrackets >= 2 && numberOfOpenBrackets > numberOfClosedBrackets);
}
exports.isInsideFieldArgument = isInsideFieldArgument;
/***
 * @param symbols expects e.g. '()', '[]' or '""'
 */
function isInsideAttribute(currentLineUntrimmed, position, symbols) {
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideAttribute = isInsideAttribute;
/***
 * Checks if inside e.g. "here"
 * Does not check for escaped quotation marks.
 */
function isInsideQuotationMark(currentLineUntrimmed, position) {
    let insideQuotation = false;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === '"') {
            insideQuotation = !insideQuotation;
        }
    }
    return insideQuotation;
}
exports.isInsideQuotationMark = isInsideQuotationMark;
function getSymbolBeforePosition(document, position) {
    return document.getText({
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: { line: position.line, character: position.character },
    });
}
exports.getSymbolBeforePosition = getSymbolBeforePosition;
function positionIsAfterFieldAndType(position, document, wordsBeforePosition) {
    const symbolBeforePosition = getSymbolBeforePosition(document, position);
    const symbolBeforeIsWhiteSpace = symbolBeforePosition.search(/\s/);
    const hasAtRelation = wordsBeforePosition.length === 2 && symbolBeforePosition === '@';
    const hasWhiteSpaceBeforePosition = wordsBeforePosition.length === 2 && symbolBeforeIsWhiteSpace !== -1;
    return (wordsBeforePosition.length > 2 ||
        hasAtRelation ||
        hasWhiteSpaceBeforePosition);
}
exports.positionIsAfterFieldAndType = positionIsAfterFieldAndType;
/**
 * Removes all block attribute suggestions that are invalid in this context.
 * E.g. `@@id()` when already used should not be in the suggestions.
 */
function removeInvalidAttributeSuggestions(supportedAttributes, block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        // TODO we should also remove the other suggestions if used (default()...)
        if (item.includes('@id')) {
            supportedAttributes = supportedAttributes.filter((attribute) => !attribute.label.includes('id'));
        }
    }
    return supportedAttributes;
}
function getSuggestionForModelBlockAttribute(block, lines) {
    if (block.type !== 'model') {
        return [];
    }
    // create deep copy
    const suggestions = removeInvalidAttributeSuggestions((0, klona_1.klona)(completionUtil_1.blockAttributes), block, lines);
    // We can filter on the datasource
    const datasourceProvider = getFirstDatasourceProvider(lines);
    // We can filter on the previewFeatures enbabled
    const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
    // Full text indexes (MySQL and MongoDB)
    // https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#full-text-indexes-mysql-and-mongodb
    const isFullTextAvailable = Boolean(datasourceProvider &&
        ['mysql', 'mongodb'].includes(datasourceProvider) &&
        (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('fulltextindex')));
    if (isFullTextAvailable === false) {
        // fullTextIndex is not available, we need to filter it out
        return suggestions.filter((arg) => arg.label !== '@@fulltext');
    }
    return suggestions;
}
function getSuggestionForNativeTypes(foundBlock, wordsBeforePosition, document, lines) {
    const activeFeatureFlag = declaredNativeTypes(document);
    if (foundBlock.type !== 'model' ||
        !activeFeatureFlag ||
        wordsBeforePosition.length < 2) {
        return undefined;
    }
    const datasourceName = getFirstDatasourceName(lines);
    if (!datasourceName ||
        wordsBeforePosition[wordsBeforePosition.length - 1] !== `@${datasourceName}`) {
        return undefined;
    }
    const prismaType = wordsBeforePosition[1].replace('?', '').replace('[]', '');
    const suggestions = getNativeTypes(document, prismaType);
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionForNativeTypes = getSuggestionForNativeTypes;
function getSuggestionForFieldAttribute(block, currentLine, lines, wordsBeforePosition, document) {
    if (block.type !== 'model') {
        return;
    }
    // create deep copy
    let suggestions = (0, klona_1.klona)(completionUtil_1.fieldAttributes);
    const enabledNativeTypes = declaredNativeTypes(document);
    if (!(currentLine.includes('Int') || currentLine.includes('String'))) {
        // id not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@id');
    }
    if (!currentLine.includes('DateTime')) {
        // updatedAt not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@updatedAt');
    }
    suggestions = removeInvalidAttributeSuggestions(suggestions, block, lines);
    if (enabledNativeTypes && wordsBeforePosition.length >= 2) {
        const datasourceName = getFirstDatasourceName(lines);
        const prismaType = wordsBeforePosition[1];
        const nativeTypeSuggestions = getNativeTypes(document, prismaType);
        if (datasourceName && nativeTypeSuggestions.length !== 0) {
            if (!currentLine.includes('@' + datasourceName)) {
                suggestions.push({
                    // https://code.visualstudio.com/docs/editor/intellisense#_types-of-completions
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    label: '@' + datasourceName,
                    documentation: 'Defines a custom type that should be used for this field.',
                });
            }
            else {
                suggestions.push(...nativeTypeSuggestions);
            }
        }
        else {
            console.log('Did not receive any native type suggestions from prisma-fmt call.');
        }
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFieldAttribute = getSuggestionForFieldAttribute;
function getFirstDatasourceName(lines) {
    const datasourceBlockFirstLine = lines.find((l) => l.startsWith('datasource') && l.includes('{'));
    if (!datasourceBlockFirstLine) {
        return undefined;
    }
    const indexOfBracket = datasourceBlockFirstLine.indexOf('{');
    return datasourceBlockFirstLine
        .slice('datasource'.length, indexOfBracket)
        .trim();
}
function getFirstDatasourceProvider(lines) {
    // matches provider inside datasource in any position
    // thanks to https://regex101.com for the online scratchpad
    const result = /datasource.*\{(\n|\N)\s*(.*\n)?\n*\s*provider\s=\s(\"(.*)\")[^}]+}/.exec(lines.join('\n'));
    if (!result || !result[4]) {
        return undefined;
    }
    const datasourceProvider = result[4];
    if (typeof datasourceProvider === 'string' &&
        datasourceProvider.length >= 1) {
        return datasourceProvider;
    }
}
function getAllPreviewFeaturesFromGenerators(lines) {
    // matches any `previewFeatures = [x]` in any position
    // thanks to https://regex101.com for the online scratchpad
    const previewFeaturesRegex = /previewFeatures\s=\s(\[.*\])/g;
    // we could match against all the `previewFeatures = [x]` (could be that there is more than one?)
    // var matchAll = text.matchAll(regexp)
    // for (const match of matchAll) {
    //   console.log(match);
    // }
    const result = previewFeaturesRegex.exec(lines.join('\n'));
    if (!result || !result[1]) {
        return undefined;
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const previewFeatures = JSON.parse(result[1]);
        if (Array.isArray(previewFeatures) && previewFeatures.length > 0) {
            return previewFeatures.map((it) => it.toLowerCase());
        }
    }
    catch (e) { }
    return undefined;
}
function getAllRelationNames(lines) {
    const modelNames = [];
    for (const item of lines) {
        if ((item.includes('model') || item.includes('enum')) &&
            item.includes('{')) {
            // found a block
            const blockName = (0, renameUtil_1.extractModelName)(item);
            modelNames.push(blockName);
            // block is at least 2 lines long
        }
    }
    return modelNames;
}
exports.getAllRelationNames = getAllRelationNames;
function getSuggestionsForTypes(foundBlock, lines, position, currentLineUntrimmed) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.corePrimitiveTypes);
    if (foundBlock instanceof util_1.Block) {
        // get all model names
        const modelNames = getAllRelationNames(lines);
        suggestions.push(...toCompletionItems(modelNames, vscode_languageserver_1.CompletionItemKind.Reference));
    }
    const wordsBeforePosition = currentLineUntrimmed
        .slice(0, position.character)
        .split(' ');
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const completeSuggestions = suggestions.filter((s) => s.label.length === wordBeforePosition.length);
    if (completeSuggestions.length !== 0) {
        for (const sugg of completeSuggestions) {
            suggestions.push({
                label: `${sugg.label}?`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            }, {
                label: `${sugg.label}[]`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            });
        }
    }
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionsForTypes = getSuggestionsForTypes;
/**
 * Removes all field suggestion that are invalid in this context. E.g. fields that are used already in a block will not be suggested again.
 * This function removes all field suggestion that are invalid in a certain context. E.g. in a generator block `provider, output, platforms, pinnedPlatForm`
 * are possible fields. But those fields are only valid suggestions if they haven't been used in this block yet. So in case `provider` has already been used, only
 * `output, platforms, pinnedPlatform` will be suggested.
 */
function removeInvalidFieldSuggestions(supportedFields, block, lines, position) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine || key === position.line) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        const fieldName = item.replace(/ .*/, '');
        if (supportedFields.includes(fieldName)) {
            supportedFields = supportedFields.filter((field) => field !== fieldName);
        }
    }
    return supportedFields;
}
function getSuggestionForDataSourceField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.supportedDataSourceFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
function getSuggestionForGeneratorField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.supportedGeneratorFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
/**
 * gets suggestions for block type
 */
function getSuggestionForFirstInsideBlock(blockType, lines, position, block) {
    let suggestions = [];
    switch (blockType) {
        case 'datasource':
            suggestions = getSuggestionForDataSourceField(block, lines, position);
            break;
        case 'generator':
            suggestions = getSuggestionForGeneratorField(block, lines, position);
            break;
        case 'model':
            suggestions = getSuggestionForModelBlockAttribute(block, lines);
            break;
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFirstInsideBlock = getSuggestionForFirstInsideBlock;
function getSuggestionForBlockTypes(lines) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.allowedBlockTypes);
    // enum is not supported in sqlite
    let foundDataSourceBlock = false;
    for (const item of lines) {
        if (item.includes('datasource')) {
            foundDataSourceBlock = true;
            continue;
        }
        if (foundDataSourceBlock) {
            if (item.includes('}')) {
                break;
            }
            if (item.startsWith('provider') && item.includes('sqlite')) {
                suggestions.pop();
            }
        }
        if (!suggestions.map((sugg) => sugg.label).includes('enum')) {
            break;
        }
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForBlockTypes = getSuggestionForBlockTypes;
function suggestEqualSymbol(blockType) {
    if (!(blockType == 'datasource' || blockType == 'generator')) {
        return;
    }
    const equalSymbol = { label: '=' };
    return {
        items: [equalSymbol],
        isIncomplete: false,
    };
}
exports.suggestEqualSymbol = suggestEqualSymbol;
function getValuesInsideSquareBrackets(line) {
    const regexp = /\[([^\]]+)\]/;
    const matches = regexp.exec(line);
    if (!matches || !matches[1]) {
        return [];
    }
    const result = matches[1].split(',');
    return result.map((v) => v.trim().replace('"', '').replace('"', ''));
}
exports.getValuesInsideSquareBrackets = getValuesInsideSquareBrackets;
function declaredNativeTypes(document) {
    const nativeTypes = (0, nativeTypes_1.default)(document.getText());
    if (nativeTypes.length === 0) {
        return false;
    }
    return true;
}
function handlePreviewFeatures(previewFeaturesArray, position, currentLineUntrimmed, isInsideQuotation) {
    let previewFeatures = previewFeaturesArray.map((pf) => vscode_languageserver_1.CompletionItem.create(pf));
    if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        if (isInsideQuotation) {
            const usedValues = getValuesInsideSquareBrackets(currentLineUntrimmed);
            previewFeatures = previewFeatures.filter((t) => !usedValues.includes(t.label));
            return {
                items: previewFeatures,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('[')),
                isIncomplete: true,
            };
        }
    }
    else {
        return {
            items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('"')),
            isIncomplete: true,
        };
    }
}
function getNativeTypes(document, prismaType) {
    let nativeTypes = (0, nativeTypes_1.default)(document.getText());
    if (nativeTypes.length === 0) {
        return [];
    }
    const suggestions = [];
    nativeTypes = nativeTypes.filter((n) => n.prisma_types.includes(prismaType));
    nativeTypes.forEach((element) => {
        if (element._number_of_args + element._number_of_optional_args !== 0) {
            let documentation = '';
            if (element._number_of_optional_args !== 0) {
                documentation = `${documentation}Number of optional arguments: ${element._number_of_optional_args}.\n'`;
            }
            if (element._number_of_args !== 0) {
                documentation = `${documentation}Number of required arguments: ${element._number_of_args}.\n`;
            }
            suggestions.push({
                label: `${element.name}()`,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                insertText: `${element.name}($0)`,
                documentation: { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentation },
                insertTextFormat: 2,
            });
        }
        else {
            suggestions.push({
                label: element.name,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
            });
        }
    });
    return suggestions;
}
// Suggest fields for a BlockType
function getSuggestionForSupportedFields(blockType, currentLine, currentLineUntrimmed, position, lines) {
    let suggestions = [];
    const isInsideQuotation = isInsideQuotationMark(currentLineUntrimmed, position);
    switch (blockType) {
        case 'generator':
            // provider
            if (currentLine.startsWith('provider')) {
                const providers = completionUtil_1.generatorProviders;
                if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.generatorProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            // previewFeatures
            if (currentLine.startsWith('previewFeatures')) {
                const generatorPreviewFeatures = (0, previewFeatures_1.default)();
                if (generatorPreviewFeatures.length > 0) {
                    return handlePreviewFeatures(generatorPreviewFeatures, position, currentLineUntrimmed, isInsideQuotation);
                }
            }
            // engineType
            if (currentLine.startsWith('engineType')) {
                const engineTypesCompletion = completionUtil_1.engineTypes;
                if (isInsideQuotation) {
                    // We can filter on the previewFeatures enbabled
                    const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
                    if (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('dataproxy')) {
                        return {
                            items: engineTypesCompletion,
                            isIncomplete: true,
                        };
                    }
                    else {
                        // filter out dataproxy engineType
                        return {
                            items: engineTypesCompletion.filter((arg) => arg.label !== 'dataproxy'),
                            isIncomplete: true,
                        };
                    }
                }
                else {
                    return {
                        items: completionUtil_1.engineTypeArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
        case 'datasource':
            // provider
            if (currentLine.startsWith('provider')) {
                let providers = (0, klona_1.klona)(completionUtil_1.dataSourceProviders);
                if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
                    // return providers that haven't been used yet
                    if (isInsideQuotation) {
                        const usedValues = getValuesInsideSquareBrackets(currentLineUntrimmed);
                        providers = providers.filter((t) => !usedValues.includes(t.label));
                        return {
                            items: providers,
                            isIncomplete: true,
                        };
                    }
                    else {
                        return {
                            items: completionUtil_1.dataSourceProviderArguments.filter((arg) => !arg.label.includes('[')),
                            isIncomplete: true,
                        };
                    }
                }
                else if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.dataSourceProviderArguments,
                        isIncomplete: true,
                    };
                }
                // url
            }
            else if (currentLine.startsWith('url')) {
                // check if inside env
                if (isInsideAttribute(currentLineUntrimmed, position, '()')) {
                    suggestions = ['DATABASE_URL'];
                }
                else {
                    if (currentLine.includes('env')) {
                        return {
                            items: completionUtil_1.dataSourceUrlArguments.filter((a) => !a.label.includes('env')),
                            isIncomplete: true,
                        };
                    }
                    return {
                        items: completionUtil_1.dataSourceUrlArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
    }
    return {
        items: toCompletionItems(suggestions, vscode_languageserver_1.CompletionItemKind.Constant),
        isIncomplete: false,
    };
}
exports.getSuggestionForSupportedFields = getSuggestionForSupportedFields;
function getDefaultValues(currentLine, lines) {
    const suggestions = [
        {
            label: 'dbgenerated("")',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'The SQL definition of the default value which is generated by the database. This is not validated by Prisma.',
            insertText: 'dbgenerated("$0")',
            insertTextFormat: 2,
        },
    ];
    const fieldType = getFieldType(currentLine);
    if (!fieldType) {
        return [];
    }
    switch (fieldType) {
        case 'Int':
            suggestions.push({
                label: 'autoincrement()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: 'Create a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.',
            });
            break;
        case 'DateTime':
            suggestions.push({
                label: 'now()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Set a timestamp of the time when a record is created.',
                },
            });
            break;
        case 'String':
            suggestions.push({
                label: 'uuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) spec.',
                },
            }, {
                label: 'cuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [cuid](https://github.com/ericelliott/cuid) spec.',
                },
            });
            break;
        case 'Boolean':
            suggestions.push({ label: 'true', kind: vscode_languageserver_1.CompletionItemKind.Value }, { label: 'false', kind: vscode_languageserver_1.CompletionItemKind.Value });
            break;
    }
    const modelOrEnum = (0, util_1.getModelOrEnumBlock)(fieldType, lines);
    if (modelOrEnum && modelOrEnum.type === 'enum') {
        // get fields from enum block for suggestions
        const values = getFieldsFromCurrentBlock(lines, modelOrEnum);
        values.forEach((v) => suggestions.push({ label: v, kind: vscode_languageserver_1.CompletionItemKind.Value }));
    }
    return suggestions;
}
// checks if e.g. inside 'fields' or 'references' attribute
function isInsideGivenProperty(currentLineUntrimmed, wordsBeforePosition, attributeName, position) {
    if (!isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        return false;
    }
    // We sort all attributes by their position
    const sortedAttributes = [
        {
            name: 'fields',
            position: wordsBeforePosition.findIndex((word) => word.includes('fields')),
        },
        {
            name: 'references',
            position: wordsBeforePosition.findIndex((word) => word.includes('references')),
        },
    ].sort((a, b) => (a.position < b.position ? 1 : -1));
    // If the last attribute (higher position)
    // is the one we are looking for we are in this attribute
    if (sortedAttributes[0].name === attributeName) {
        return true;
    }
    else {
        return false;
    }
}
function getFieldsFromCurrentBlock(lines, block, position) {
    const suggestions = [];
    let reachedStartLine = false;
    let field = '';
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            field = item.replace(/ .*/, '');
            if (field !== '' && !field.startsWith('//')) {
                suggestions.push(field);
            }
        }
    }
    return suggestions;
}
function getTypesFromCurrentBlock(lines, block, position) {
    const suggestions = new Map();
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            const type = getFieldType(item);
            if (type !== undefined) {
                /* eslint-disable @typescript-eslint/no-unsafe-assignment */
                const existingSuggestion = suggestions.get(type);
                if (!existingSuggestion) {
                    suggestions.set(type, [key]);
                }
                else {
                    existingSuggestion.push(key);
                    suggestions.set(type, existingSuggestion);
                }
                /* eslint-enable @typescript-eslint/no-unsafe-assignment */
            }
        }
    }
    return suggestions;
}
exports.getTypesFromCurrentBlock = getTypesFromCurrentBlock;
function getFieldType(line) {
    const wordsInLine = line.split(/\s+/);
    if (wordsInLine.length < 2) {
        return undefined;
    }
    const type = wordsInLine[1];
    if (type.length !== 0) {
        return type;
    }
    return undefined;
}
// function definingReferentialAction(
//   wordsBeforePosition: Array<string>,
// ): boolean {
//   const lastWord = wordsBeforePosition[wordsBeforePosition.length - 2]
//   return (
//     lastWord != undefined &&
//     (lastWord.includes('onDelete') || lastWord.includes('onUpdate'))
//   )
// }
function getSuggestionsForAttribute({ attribute, wordsBeforePosition, untrimmedCurrentLine, lines, block, position, }) {
    const firstWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const secondWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 2];
    const wordBeforePosition = firstWordBeforePosition === ''
        ? secondWordBeforePosition
        : firstWordBeforePosition;
    const stringTilPosition = untrimmedCurrentLine
        .slice(0, position.character)
        .trim();
    let suggestions = [];
    // create deep copy with klona
    if (attribute === '@relation') {
        suggestions = (0, klona_1.klona)(completionUtil_1.relationArguments);
        // This is basically hardcoding the suggestions
        // because prisma-format referential-actions returns an empty array [] most of the time
        // because schema is considered invalid when it's sent to the subcommand because typing in progress.
        // Main issue is that "Restrict" should be excluded if on SQL Server
        // We can filter on the datasource using `getFirstDatasourceProvider`
        const datasourceProvider = getFirstDatasourceProvider(lines);
        // Note: needs to be before @relation condition because
        // includes because `@relation(onUpdate: |)` means wordBeforePosition = '@relation(onUpdate:'
        if (wordBeforePosition.includes('onDelete:')) {
            return {
                items: datasourceProvider === 'sqlserver'
                    ? completionUtil_1.relationOnDeleteArguments.filter((arg) => arg.label !== 'Restrict')
                    : completionUtil_1.relationOnDeleteArguments,
                isIncomplete: false,
            };
        }
        if (wordBeforePosition.includes('onUpdate:')) {
            return {
                items: datasourceProvider === 'sqlserver'
                    ? completionUtil_1.relationOnUpdateArguments.filter((arg) => arg.label !== 'Restrict')
                    : completionUtil_1.relationOnUpdateArguments,
                isIncomplete: false,
            };
        }
        // If we are right after @relation(
        if (wordBeforePosition.includes('@relation')) {
            return {
                items: suggestions,
                isIncomplete: false,
            };
        }
        // Doesn't really work because prisma-fmt returns nothing when the schema is "invalid"
        // but that also means that the schema is considered invalid when trying to autocomplete...
        //
        // if lastWord = onUpdate or onDelete
        // then get suggestions by passing `referential-actions` arg to `prisma-fmt`
        // if (definingReferentialAction(wordsBeforePosition)) {
        //   const suggestionsForReferentialActions: CompletionItem[] = referentialActions(
        //     binPath,
        //     document.getText(),
        //   ).map((action) => {
        //     return CompletionItem.create(action)
        //   })
        //   return {
        //     items: suggestionsForReferentialActions,
        //     isIncomplete: false,
        //   }
        // }
        if (isInsideGivenProperty(untrimmedCurrentLine, wordsBeforePosition, 'fields', position)) {
            return {
                items: toCompletionItems(getFieldsFromCurrentBlock(lines, block, position), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        if (isInsideGivenProperty(untrimmedCurrentLine, wordsBeforePosition, 'references', position)) {
            const referencedModelName = wordsBeforePosition[1].replace('?', '');
            const referencedBlock = (0, util_1.getModelOrEnumBlock)(referencedModelName, lines);
            // referenced model does not exist
            if (!referencedBlock || referencedBlock.type !== 'model') {
                return;
            }
            return {
                items: toCompletionItems(getFieldsFromCurrentBlock(lines, referencedBlock), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
    }
    else {
        // @id, @unique
        // @@id, @@unique, @@index, @@fulltext
        // The length argument is available on MySQL only on the
        // @id, @@id, @unique, @@unique and @@index fields.
        // The sort argument is available for all databases on the
        // @unique, @@unique and @@index fields.
        // Additionally, SQL Server also allows it on @id and @@id.
        // We can filter on the datasource
        const datasourceProvider = getFirstDatasourceProvider(lines);
        // We can filter on the previewFeatures enbabled
        const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
        if (isInsideAttribute(untrimmedCurrentLine, position, '[]')) {
            // extendedIndexes
            if ((previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('extendedindexes')) &&
                isInsideFieldArgument(untrimmedCurrentLine, position)) {
                let attribute = undefined;
                if (wordsBeforePosition.some((a) => a.includes('@@id'))) {
                    attribute = '@@id';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@id'))) {
                    attribute = '@id';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@@unique'))) {
                    attribute = '@@unique';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@unique'))) {
                    attribute = '@unique';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
                    attribute = '@@index';
                }
                if (attribute) {
                    return {
                        items: (0, completionUtil_1.filterSortLengthBasedOnInput)(attribute, previewFeatures, datasourceProvider, wordBeforePosition, completionUtil_1.sortLengthProperties),
                        isIncomplete: false,
                    };
                }
            }
            let items = getFieldsFromCurrentBlock(lines, block, position);
            // get parameters inside block attribute
            const parameterMatch = new RegExp(/(?<=\[).+?(?=\])/).exec(untrimmedCurrentLine);
            if (parameterMatch) {
                const existingParameters = parameterMatch[0]
                    .split(',')
                    .map((param) => param.trim());
                items = items.filter((s) => !existingParameters.includes(s));
            }
            return {
                items: toCompletionItems(items, vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        // "@@" block attributes
        let blockAtrributeArguments = [];
        if (wordsBeforePosition.some((a) => a.includes('@@unique'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@unique');
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@id'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@id');
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
            // Auto completion for Hash and BTree for PostgreSQL
            // includes because `@@index(type: |)` means wordBeforePosition = '@@index(type:'
            // TODO figure out if we need to add cockroachdb provider here
            if (datasourceProvider &&
                ['postgresql', 'postgres'].includes(datasourceProvider) &&
                wordBeforePosition.includes('type:')) {
                // TODO move away
                const indexTypeCompletionItems = [
                    {
                        label: 'Hash',
                        kind: 13,
                        insertTextFormat: 1,
                        documentation: {
                            kind: 'markdown',
                            value: 'The Hash index can perform a faster lookup than a B-Tree index. However, the key downside of the Hash index is that its use is limited to equality operators that will perform matching operations.',
                        },
                    },
                    {
                        label: 'BTree',
                        kind: 13,
                        insertTextFormat: 1,
                        documentation: {
                            kind: 'markdown',
                            value: "The B-tree index is the default, it creates a self-balanced tree, in other words, it sorts itself. It will maintain its balance throughout operations such as insertions, deletions and searches. Using a B-tree index speeds up scan operations because it doesn't have to scan pages or records sequentially in a linear fashion.",
                        },
                    },
                ];
                return {
                    items: indexTypeCompletionItems,
                    isIncomplete: false,
                };
            }
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@index', previewFeatures, datasourceProvider);
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@fulltext'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@fulltext');
        }
        if (blockAtrributeArguments.length) {
            suggestions = blockAtrributeArguments;
        }
        else {
            // "@" field attributes
            let fieldAtrributeArguments = [];
            if (wordsBeforePosition.some((a) => a.includes('@unique'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@unique', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            else if (wordsBeforePosition.some((a) => a.includes('@id'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@id', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@@index', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            suggestions = fieldAtrributeArguments;
        }
    }
    // Example: @relation(fields: [authorId], references: [id], |)
    if (stringTilPosition.endsWith(',')) {
        // Check which attributes are already present
        // so we can filter them out from the suggestions
        const attributesFound = new Set();
        for (const word of wordsBeforePosition) {
            if (word.includes('references')) {
                attributesFound.add('references');
            }
            if (word.includes('fields')) {
                attributesFound.add('fields');
            }
            if (word.includes('onUpdate')) {
                attributesFound.add('onUpdate');
            }
            if (word.includes('onDelete')) {
                attributesFound.add('onDelete');
            }
            if (word.includes('map')) {
                attributesFound.add('map');
            }
            if (word.includes('name') || /".*"/.exec(word)) {
                attributesFound.add('name');
                attributesFound.add('""');
            }
            if (word.includes('type')) {
                attributesFound.add('type');
            }
        }
        // now filter them out of the suggestions as they are already present
        const filteredSuggestions = suggestions.reduce((accumulator, sugg) => {
            let suggestionMatch = false;
            for (const attribute of attributesFound) {
                if (sugg.label.includes(attribute)) {
                    suggestionMatch = true;
                }
            }
            if (!suggestionMatch) {
                accumulator.push(sugg);
            }
            return accumulator;
        }, []);
        // nothing to present any more, return
        if (filteredSuggestions.length === 0) {
            return;
        }
        return {
            items: filteredSuggestions,
            isIncomplete: false,
        };
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
function getSuggestionsForInsideRoundBrackets(untrimmedCurrentLine, lines, document, position, block) {
    const wordsBeforePosition = untrimmedCurrentLine
        .slice(0, position.character)
        .trimLeft()
        .split(/\s+/);
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    if (wordBeforePosition.includes('@default')) {
        return {
            items: getDefaultValues(lines[position.line], lines),
            isIncomplete: false,
        };
    }
    else if (wordsBeforePosition.some((a) => a.includes('@relation'))) {
        return getSuggestionsForAttribute({
            attribute: '@relation',
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else if (
    // matches
    // @id, @unique
    // @@id, @@unique, @@index, @@fulltext
    wordsBeforePosition.some((a) => a.includes('@unique') ||
        a.includes('@id') ||
        a.includes('@@index') ||
        a.includes('@@fulltext'))) {
        return getSuggestionsForAttribute({
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else {
        return {
            items: toCompletionItems([], vscode_languageserver_1.CompletionItemKind.Field),
            isIncomplete: false,
        };
    }
}
exports.getSuggestionsForInsideRoundBrackets = getSuggestionsForInsideRoundBrackets;
//# sourceMappingURL=completions.js.map